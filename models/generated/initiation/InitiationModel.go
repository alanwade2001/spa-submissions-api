// Code generated by schema-generate. DO NOT EDIT.

package initiation

import (
    "bytes"
    "errors"
    "encoding/json"
)

// AccountReference AccountReference
type AccountReference struct {
  BIC string `json:"BIC,omitempty"`

  // The unique identifier for the account
  IBAN string `json:"IBAN,omitempty"`
  Name string `json:"Name,omitempty"`
}

// CustomerReference CustomerReference
type CustomerReference struct {

  // The unique identifier for a customer
  CustomerId string `json:"CustomerId,omitempty"`

  // The name of the customer
  CustomerName string `json:"CustomerName,omitempty"`
}

// GroupHeaderReference GroupHeader Reference of the initiation
type GroupHeaderReference struct {
  ControlSum float64 `json:"ControlSum,omitempty"`
  CreationDateTime string `json:"CreationDateTime,omitempty"`
  InitiatingPartyId string `json:"InitiatingPartyId,omitempty"`
  MessageId string `json:"MessageId,omitempty"`
  NumberOfTransactions float64 `json:"NumberOfTransactions,omitempty"`
}

// InitiationModel 
type InitiationModel struct {
  Customer *CustomerReference `json:"Customer,omitempty"`
  GroupHeader *GroupHeaderReference `json:"GroupHeader"`
  Id string `json:"_id,omitempty"`
  PaymentInstructions []*PaymentInstructionReference `json:"PaymentInstructions,omitempty"`
}

// PaymentInstructionReference PaymentInstruction Reference of the initiation
type PaymentInstructionReference struct {
  ControlSum float64 `json:"ControlSum,omitempty"`
  DebtorAccount *AccountReference `json:"DebtorAccount,omitempty"`
  NumberOfTransactions float64 `json:"NumberOfTransactions,omitempty"`
  PaymentId string `json:"PaymentId,omitempty"`
  RequestedExecutionDate string `json:"RequestedExecutionDate,omitempty"`
}

// SubmissionReference CustomerReference
type SubmissionReference struct {

  // The unique identifier for a customer
  SubmissionId string `json:"SubmissionId,omitempty"`
  SubmittedAt string `json:"SubmittedAt,omitempty"`
  SubmittedBy string `json:"SubmittedBy,omitempty"`
}

func (strct *InitiationModel) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "Customer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"Customer\": ")
	if tmp, err := json.Marshal(strct.Customer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "GroupHeader" field is required
    if strct.GroupHeader == nil {
        return nil, errors.New("GroupHeader is a required field")
    }
    // Marshal the "GroupHeader" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"GroupHeader\": ")
	if tmp, err := json.Marshal(strct.GroupHeader); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "_id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"_id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "PaymentInstructions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"PaymentInstructions\": ")
	if tmp, err := json.Marshal(strct.PaymentInstructions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InitiationModel) UnmarshalJSON(b []byte) error {
    GroupHeaderReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "Customer":
            if err := json.Unmarshal([]byte(v), &strct.Customer); err != nil {
                return err
             }
        case "GroupHeader":
            if err := json.Unmarshal([]byte(v), &strct.GroupHeader); err != nil {
                return err
             }
            GroupHeaderReceived = true
        case "_id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "PaymentInstructions":
            if err := json.Unmarshal([]byte(v), &strct.PaymentInstructions); err != nil {
                return err
             }
        }
    }
    // check if GroupHeader (a required property) was received
    if !GroupHeaderReceived {
        return errors.New("\"GroupHeader\" is required but was not present")
    }
    return nil
}
