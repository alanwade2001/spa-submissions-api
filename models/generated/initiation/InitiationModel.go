// Code generated by schema-generate. DO NOT EDIT.

package initiation

import (
    "bytes"
    "encoding/json"
    "errors"
)

// AccountReference AccountReference
type AccountReference struct {
  BIC string `json:"BIC,omitempty"`

  // The unique identifier for the account
  IBAN string `json:"IBAN,omitempty"`
  Name string `json:"Name,omitempty"`
}

// CustomerReference CustomerReference
type CustomerReference struct {

  // The unique identifier for a customer
  CustomerId string `json:"CustomerId"`

  // The name of the customer
  CustomerName string `json:"CustomerName"`
}

// GroupHeaderReference GroupHeader Reference of the initiation
type GroupHeaderReference struct {
  ControlSum float64 `json:"ControlSum,omitempty"`
  CreationDateTime string `json:"CreationDateTime,omitempty"`
  InitiatingPartyId string `json:"InitiatingPartyId,omitempty"`
  MessageId string `json:"MessageId,omitempty"`
  NumberOfTransactions float64 `json:"NumberOfTransactions,omitempty"`
}

// InitiationModel 
type InitiationModel struct {
  Customer *CustomerReference `json:"Customer,omitempty"`
  GroupHeader *GroupHeaderReference `json:"GroupHeader,omitempty"`
  Id string `json:"_id,omitempty"`
  PaymentInstructions []*PaymentInstructionReference `json:"PaymentInstructions,omitempty"`
}

// PaymentInstructionReference PaymentInstruction Reference of the initiation
type PaymentInstructionReference struct {
  ControlSum float64 `json:"ControlSum,omitempty"`
  DebtorAccount *AccountReference `json:"DebtorAccount,omitempty"`
  NumberOfTransactions float64 `json:"NumberOfTransactions,omitempty"`
  PaymentId string `json:"PaymentId,omitempty"`
  RequestedExecutionDate string `json:"RequestedExecutionDate,omitempty"`
}

// SubmissionReference CustomerReference
type SubmissionReference struct {

  // The unique identifier for a customer
  SubmissionId string `json:"SubmissionId,omitempty"`
  SubmittedAt string `json:"SubmittedAt,omitempty"`
  SubmittedBy string `json:"SubmittedBy,omitempty"`
}

func (strct *CustomerReference) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CustomerId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CustomerId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomerId\": ")
	if tmp, err := json.Marshal(strct.CustomerId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CustomerName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "CustomerName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"CustomerName\": ")
	if tmp, err := json.Marshal(strct.CustomerName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CustomerReference) UnmarshalJSON(b []byte) error {
    CustomerIdReceived := false
    CustomerNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "CustomerId":
            if err := json.Unmarshal([]byte(v), &strct.CustomerId); err != nil {
                return err
             }
            CustomerIdReceived = true
        case "CustomerName":
            if err := json.Unmarshal([]byte(v), &strct.CustomerName); err != nil {
                return err
             }
            CustomerNameReceived = true
        }
    }
    // check if CustomerId (a required property) was received
    if !CustomerIdReceived {
        return errors.New("\"CustomerId\" is required but was not present")
    }
    // check if CustomerName (a required property) was received
    if !CustomerNameReceived {
        return errors.New("\"CustomerName\" is required but was not present")
    }
    return nil
}
